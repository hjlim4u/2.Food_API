# Cursor Rules for Food API

You are an expert in Python, FastAPI, and scalable API development.

## Key Principles
- Write concise, technical responses with accurate Python examples.
- Use functional, declarative programming; avoid classes where possible.
- Prefer iteration and modularization over code duplication.
- Use descriptive variable names with auxiliary verbs (e.g., is_active, has_permission).
- Use lowercase with underscores for directories and files (e.g., routers/user_routes.py).
- Favor named exports for routes and utility functions.
- Use the Receive an Object, Return an Object (RORO) pattern.

## Python/FastAPI
- Use def for pure functions and async def for asynchronous operations.
- Use type hints for all function signatures. Prefer Pydantic models over raw dictionaries for input validation.
- File structure: exported router, sub-routes, utilities, static content, types (models, schemas).
- Avoid unnecessary curly braces in conditional statements.
- For single-line statements in conditionals, omit curly braces.
- Use concise, one-line syntax for simple conditional statements (e.g., if condition: do_something()).

## Database and ORM Guidelines
- Use SQLAlchemy 2.0 with async support for database operations
- Define clear separation between database models and Pydantic schemas
- Implement repository pattern for database operations
- Use database transactions for data consistency
- Example structure:
  ```python
  # models/food.py
  class Food(Base):
      __tablename__ = "foods"
      id = Column(Integer, primary_key=True)
      food_cd = Column(String, unique=True, nullable=False)
      # ... other fields
  
  # schemas/food.py
  class FoodBase(BaseModel):
      food_cd: str
      group_name: str
      # ... other fields
  
  class FoodCreate(FoodBase):
      pass
  
  class FoodResponse(FoodBase):
      id: int
      model_config = ConfigDict(from_attributes=True)
  ```

## Search and Filtering Implementation
- Use query parameters with Optional types for flexible search
- Implement query builders for complex search logic
- Use database-level filtering for performance
- Example search implementation:
  ```python
  async def search_foods(
      food_name: Optional[str] = None,
      research_year: Optional[str] = None,
      maker_name: Optional[str] = None,
      food_code: Optional[str] = None,
      db: AsyncSession = Depends(get_db)
  ):
      query = select(Food)
      if food_name:
          query = query.where(Food.food_name.contains(food_name))
      if research_year:
          query = query.where(Food.research_year == research_year)
      # ... apply other filters
      result = await db.execute(query)
      return result.scalars().all()
  ```

## Pagination Guidelines
- Implement consistent pagination across all list endpoints
- Use limit/offset or cursor-based pagination
- Return pagination metadata with responses
- Example:
  ```python
  class PaginationParams(BaseModel):
      page: int = Field(default=1, ge=1)
      limit: int = Field(default=20, le=100)
  
  class PaginatedResponse(BaseModel, Generic[T]):
      data: List[T]
      pagination: dict
  ```

## Error Handling and Validation
- Prioritize error handling and edge cases:
  - Handle errors and edge cases at the beginning of functions.
  - Use early returns for error conditions to avoid deeply nested if statements.
  - Place the happy path last in the function for improved readability.
  - Avoid unnecessary else statements; use the if-return pattern instead.
  - Use guard clauses to handle preconditions and invalid states early.
  - Implement proper error logging and user-friendly error messages.
  - Use custom error types or error factories for consistent error handling.
- Implement custom validators for business logic:
  ```python
  @field_validator('research_year')
  def validate_year(cls, v):
      if not re.match(r'^\d{4}$', v):
          raise ValueError('Year must be in YYYY format')
      return v
  ```

## API Versioning
- Include version in URL path (e.g., /v1/foods)
- Use route prefixes for version management
- Maintain backward compatibility when possible

## Dependencies
- FastAPI
- Pydantic v2
- SQLAlchemy 2.0 (with async support)
- asyncpg (for PostgreSQL) or aiomysql (for MySQL)
- python-multipart (for form data)
- httpx (for async HTTP clients)

## FastAPI-Specific Guidelines
- Use functional components (plain functions) and Pydantic models for input validation and response schemas.
- Use declarative route definitions with clear return type annotations.
- Use def for synchronous operations and async def for asynchronous ones.
- Minimize @app.on_event("startup") and @app.on_event("shutdown"); prefer lifespan context managers for managing startup and shutdown events.
- Use middleware for logging, error monitoring, and performance optimization.
- Optimize for performance using async functions for I/O-bound tasks, caching strategies, and lazy loading.
- Use HTTPException for expected errors and model them as specific HTTP responses.
- Use middleware for handling unexpected errors, logging, and error monitoring.
- Use Pydantic's BaseModel for consistent input/output validation and response schemas.

## Performance Optimization
- Minimize blocking I/O operations; use asynchronous operations for all database calls and external API requests.
- Implement caching for static and frequently accessed data using tools like Redis or in-memory stores.
- Optimize data serialization and deserialization with Pydantic.
- Use lazy loading techniques for large datasets and substantial API responses.
- Implement database query optimization:
  - Use select specific columns when full object not needed
  - Implement eager loading for related data
  - Use database indexes for frequently searched fields

## Testing Guidelines
- Write unit tests for business logic
- Use pytest with async support
- Mock database operations in tests
- Test edge cases and error scenarios

## Key Conventions
1. Rely on FastAPI's dependency injection system for managing state and shared resources.
2. Prioritize API performance metrics (response time, latency, throughput).
3. Limit blocking operations in routes:
   - Favor asynchronous and non-blocking flows.
   - Use dedicated async functions for database and external API operations.
   - Structure routes and dependencies clearly to optimize readability and maintainability.
4. Follow RESTful conventions:
   - Use appropriate HTTP methods (GET, POST, PUT, PATCH, DELETE)
   - Return appropriate status codes
   - Use resource-based URLs
5. Implement comprehensive request/response logging
6. Use environment variables for configuration

## Food API Specific Guidelines
1. Validate nutritional values (non-negative numbers)
2. Ensure food_cd uniqueness at database level
3. Implement partial updates with PATCH method
4. Handle Korean text properly with UTF-8 encoding
5. Consider implementing bulk operations for efficiency
6. Add data export functionality (CSV, JSON)

Refer to FastAPI documentation for Data Models, Path Operations, and Middleware for best practices.